# 并发
指两个或多个事件在同一个时间段内发生

# 并行
指两个或多个事件在同一时刻发生(同时发生)

# 进程
指一个内存中运行得应用程序，每个进程都有一个独立得内存空间，一个应用程序可以同时运行多个进程
进程也是程序得一次执行过程，是系统运行程序得基本单位
系统运行一个程序即是一个进程从创建、运行到消亡得过程
任何一个应用程序都要进入到内存中

# 线程
线程是进程中的一个执行单元，负责当前进程中程序的执行，一个进程中至少有一个线程
一个进程中是可以有多个线程的，这个应用程序也可以称之为多线程程序
# 多线程好处
    1. 效率高
    2. 多个线程之间互不影响
# 线程调度
    ·分时调度
        所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间
    ·抢占式调度
        优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个(线程随机性),Java使用的为抢占式调度


总结：
一个程序运行后至少有一个进程，一个进程中可以包含多个线程
线程属于进程

CPU：中央处理器
分类：
    AMD
    Inter (Inter Core i5 9300H 4核8线程)
    8线程：可以同时执行8个任务


RAM 和 ROM
# RAM(Random Access Memory)：随机存储内存
在断电时将丢失其存储内容，用于存储短时间使用的程序

# ROM(Read-Only Memory)：只读内存(硬盘)
只能读出实现所存数据的固态半导体存储器

### 线程安全
· 单线程程序不会出现线程安全问题 (实例：电影院一个窗口卖 100 张票)
· 多线程程序，没有访问共享数据，不会产生问题 (实例：3个窗口卖不同的票)
· 多线程程序访问共享的数据，会产生线程安全问题 (实例：3个窗口卖的票是一样的)

### 解决方法
线程同步 (同步机制 关键字：synchronized)
1. 同步代码块
    格式：
        synchronized(锁对象) {
            可能出现线程安全问题的代码(访问了共享数据的代码)
        }

    注意：
        1. 通过代码块中的锁对象，可以使用任意的对象
        2. 但是必须保证多个线程使用的锁对象是同一个
        3. 锁对象作用：
            把同步代码块锁住，只让一个线程在同步代码块中执行
    原理：
        使用了一个锁对象，这个锁对象叫 同步锁，也叫 对象锁，也叫对象监视器
        3 个线程一起抢夺 cpu 的执行权，谁抢到了谁执行 run 方法进行卖票
            t0 抢到了 cpu 的执行权，执行 run 方法，遇到 synchronized 代码块
            这时 t0 会检查 synchronized 代码块是否有锁对象
            发现有，就会获取到锁对象，进入到同步中执行

            t1 抢到了 cpu 的执行权，执行 run 方法，遇到 synchronized 代码块
            这时 t1 会检查 synchronized 代码块是否有锁对象
            发现没有，t1 就会进入到阻塞状态，会一直等待 t0 线程归还锁对象
            一直到 t0 线程执行完同步中的代码，会把锁对象归还给同步代码块
            t1 才能获取到锁对象进入到同步中执行

    总结：同步中的线程，没有执行完毕不会释放锁，同步外的线程没有锁进不去同步
         保证了只能有一个线程在同步中执行共享数据
         保证了安全
         程序频繁的判断锁，获取锁，程序的效率会降低

2. 同步方法
    使用步骤：
        1. 把访问了共享数据的代码抽取出来，放到一个方法中
        2. 在方法上添加 synchronized 修饰符

    格式：定义方法的格式
    修饰符 synchronized 返回值类型 方法名(参数列表) {
         可能出现线程安全问题的代码(访问了共享数据的代码)
    }

    定义一个同步方法
        同步方法也会把方法内部的代码锁住
        只让一个线程执行
        同步方法的锁对象是谁？
        就是实现类对象 new RunnableImpl()
        也就是 this

    定义一个静态同步方法
            锁对象是谁？
            不能是 this
            this 是创建对象之后产生的，静态方法优先于对象
            静态方法的锁对象是本类的 class 属性 --> class 文件对象(反射)

3. 锁机制
    java.util.concurrent.locks 接口
    Lock 实现提供了比使用 synchronized 方法和语句可获得的更广泛的锁定操作。
    Lock 接口中用到的方法：
        void lock(): 获取锁
        void unlock(): 释放锁
    java.util.concurrent.locks.ReentrantLock implements Lock 接口

    使用步骤：
        1. 在成员位置创建一个 ReentrantLock 对象
        2. 在可能会出现安全问题的代码前调用 Lock 接口中的方法 lock 获取锁
        3. 在可能会出现安全问题的代码前调用 Lock 接口中的方法 unlock 释放锁

线程状态。线程可以处于下列状态之一：

NEW
至今尚未启动的线程处于这种状态。
RUNNABLE
正在 Java 虚拟机中执行的线程处于这种状态。
BLOCKED
受阻塞并等待某个监视器锁的线程处于这种状态。
WAITING
无限期地等待另一个线程来执行某一特定操作的线程处于这种状态。
TIMED_WAITING
等待另一个线程来执行取决于指定等待时间的操作的线程处于这种状态。
TERMINATED
已退出的线程处于这种状态。
在给定时间点上，一个线程只能处于一种状态。这些状态是虚拟机状态，它们并没有反映所有操作系统线程状态。
