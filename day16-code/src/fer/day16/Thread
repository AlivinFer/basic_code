### 线程间通信
多个线程在处理同一个资源，但是处理的动作(线程的任务) 却不相同

为什么要处理线程间通信
    多个线程并发执行时，在默认情况下 CPU 是随机切换线程的，当我们需要多个线程来共同完成一任务时
    并且希望他们有规律的执行，那么多线程之间需要一些协调通信，以此来达到多线程共同操作一份数据

如何保证线程间通信有效利用资源
    多个线程在处理同一个资源，并且任务不同时，需要线程通信来帮助解决线程之间对同一个变量的使用或操作
    就是多个线程在操作同一份数据时，避免对同一共享变量的争夺
    需要通过一定的手段使各个线程能有效地利用资源 --- 等待唤醒机制

### 等待唤醒机制
这是多个线程间的一种 协作 机制
在一个线程进行了规定的操纵后，就进入 等待状态(wait()), 等待其它线程执行完他们的指定代码过后，再将其唤醒(notify())
在有多个线程进行等待时，可以使用 notifyAll() 来唤醒所有的等待线程

wait/notify 就是线程间的一种协作机制

等待唤醒中的方法
1. wait：线程不再活动，不再参与调度，进入到 wait set 中，因此不会浪费 CPU 资源，也不会去竞争锁了
这时的线程状态即是 WAITING。它还要等着别的线程执行一个 特别的操作，也即是 通知(notify) 在这个对象上
等待的线程从 wait set 中释放出来，重新进入到调度队列 (ready queue) 中

2. notify：选取所通知对象的 wait set 中的一个线程释放

3. notifyAll: 释放所通知对象的 wait set 上的全部线程

注意：
    哪怕只通知了一个等待的线程，被通知线程也不能力机恢复执行，因为它当初中断的地方是在同步块内，
    而此刻它已经不持有锁，所以它需要再次尝试去获取锁(很可能面临其它线程的竞争)，成功后才能在当初
    调用 wait 方法之后的地方恢复执行

总结：
    · 如果能获取锁，线程就从 WAITING 状态变成 RUNNABLE 状态
    · 否则，从 wait set 出来，又进入 entry set，线程就从 WAITING 状态又变成 BLOCKED 状态

调用 wait 和 notify 方法需要注意的细节

1. wait 方法与 notify 方法必须要由同一个锁对象调用。因为: 对应的锁对象可以通过 notify 唤醒使用同一个
   锁对象调用的 wait 方法后的线程

2. wait 方法与 notify 方法是属于 Object 类的方法的，因为：锁对象可以是任意对象，而任意对象的所属类型都是继承
   了 Object 类的

3. wait 方法与 notify 方法必须要在同步代码块或者同步函数中使用。
   因为必须要通过锁对象调用这两个方法

## 线程池
其实就是一个容纳多个线程的容器，其中的线程可以反复使用，省去了频繁创建线程对象的操作，无需反复创建线程而消耗过多资源
容器 -- > 集合(ArrayList, HashSet, LinkedList<Thread>, HashMap)
   当程序第一次启动的时候，创建多个线程，保存到一个集合中
   当我们想要使用线程的时候，就可以从集合中取出来线程使用

Thread t = list.remove(0); 返回的是被移除的元素(线程只能被一个任务使用)
Thread t = linked.removeFirst();
当我们使用完毕线程，需要把线程归还给线程池
list.add(t);
linked.addLast(t);

在 JDK1.5 之后，JDK 内置线程池